{
  "T test cases starter": {
    "prefix": "ttt",
    "body": [
      "#ifdef LOCAL",
      "#include \"debug.cpp\"",
      "#else",
      "#include <bits/stdc++.h>",
      "#define debug(...)",
      "#define debugArr(...)",
      "#endif",
      "",
      "using namespace std;",
      "using llong = long long;",
      "",
      "void solve() {",
      "  ${1:}",
      "}",
      "",
      "int main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  int t = 1;",
      "  cin >> t;",
      "  while (t--) {",
      "    solve();",
      "  }",
      "",
      "  return 0;",
      "}"
    ],
    "description": "T test cases starter"
  },
  "Normal CP starter": {
    "prefix": "worm",
    "body": [
      "#ifdef LOCAL",
      "#include \"debug.cpp\"",
      "#else",
      "#include <bits/stdc++.h>",
      "#define debug(...)",
      "#define debugArr(...)",
      "#endif",
      "",
      "using namespace std;",
      "using llong = long long;",
      "",
      "int main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  ${1:}",
      "",
      "  return 0;",
      "}"
    ],
    "description": "Normal CP starter"
  },
  "Disjoint Set Union": {
    "prefix": "sdsu",
    "body": [
      "class dsu {",
      "public:",
      "  int n;",
      "  std::vector<int> p;",
      "  dsu(int _n) : n(_n) {",
      "    p.resize(n);",
      "    std::iota(p.begin(), p.end(), 0);",
      "  }",
      "  int get(int x) { return (p[x] == x ? x : p[x] = get(p[x])); }",
      "  bool same(int a, int b) {",
      "    a = get(a);",
      "    b = get(b);",
      "    return a != b;",
      "  }",
      "  bool unite(int a, int b) {",
      "    a = get(a);",
      "    b = get(b);",
      "    if (a != b) {",
      "      p[a] = b;",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "};"
    ],
    "description": "Disjoint Set Union"
  },
  "GCD function": {
    "prefix": "sgcd",
    "body": [
      "int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); }",
      "llong gcd(llong a, llong b) { return (b == 0 ? a : gcd(b, a % b)); }",
      ""
    ],
    "description": "GCD function"
  },
  "Bit Manipulation": {
    "prefix": "sbits",
    "body": [
      "int bits(int a) { return __builtin_popcount(a); }",
      "int bits(llong a) { return __builtin_popcountll(a); }",
      "int lastbit(int n) { return ((n ^ (n - 1)) + 1) / 2; }",
      "llong lastbit(llong n) { return ((n ^ (n - 1)) + 1) / 2; }"
    ],
    "description": "Bit manipulation helpers"
  },
  "Disjoint Set Union": {
    "prefix": "dsu",
    "body": [
      "class dsu {",
      "public:",
      "  vector<int> p;",
      "  int n;",
      "",
      "  dsu(int _n) : n(_n) {",
      "    p.resize(n);",
      "    iota(p.begin(), p.end(), 0);",
      "  }",
      "",
      "  inline int get(int x) { return (x == p[x] ? x : (p[x] = get(p[x]))); }",
      "",
      "  inline bool unite(int x, int y) {",
      "    x = get(x);",
      "    y = get(y);",
      "    if (x != y) {",
      "      p[x] = y;",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "};"
    ],
    "description": "Disjoint Set Union"
  },
  "Debug Template": {
    "prefix": "cpdebug",
    "body": [
      "#ifndef DEBUG_TEMPLATE_CPP",
      "#define DEBUG_TEMPLATE_CPP",
      "#include <bits/stdc++.h>",
      "// #define cerr cout",
      "namespace __DEBUG_UTIL__ {",
      "using namespace std;",
      "/* Primitive Datatypes Print */",
      "void print(const char *x) { cerr << x; }",
      "void print(bool x) { cerr << (x ? \"T\" : \"F\"); }",
      "void print(char x) { cerr << '\\'' << x << '\\''; }",
      "void print(signed short int x) { cerr << x; }",
      "void print(unsigned short int x) { cerr << x; }",
      "void print(signed int x) { cerr << x; }",
      "void print(unsigned int x) { cerr << x; }",
      "void print(signed long int x) { cerr << x; }",
      "void print(unsigned long int x) { cerr << x; }",
      "void print(signed long long int x) { cerr << x; }",
      "void print(unsigned long long int x) { cerr << x; }",
      "void print(float x) { cerr << x; }",
      "void print(double x) { cerr << x; }",
      "void print(long double x) { cerr << x; }",
      "void print(string x) { cerr << '\\\"' << x << '\\\"'; }",
      "template <size_t N> void print(bitset<N> x) { cerr << x; }",
      "void print(vector<bool> v) { /* Overloaded this because stl optimizes",
      "                                vector<bool> by using _Bit_reference instead of",
      "                                bool to conserve space. */",
      "  int f = 0;",
      "  cerr << '{';",
      "  for (auto &&i : v)",
      "    cerr << (f++ ? \",\" : \"\") << (i ? \"T\" : \"F\");",
      "  cerr << \"}\";",
      "}",
      "/* Templates Declarations to support nested datatypes */",
      "template <typename T> void print(T &&x);",
      "template <typename T> void print(vector<vector<T>> mat);",
      "template <typename T, size_t N, size_t M> void print(T (&mat)[N][M]);",
      "template <typename F, typename S> void print(pair<F, S> x);",
      "template <typename T, size_t N> struct Tuple;",
      "template <typename T> struct Tuple<T, 1>;",
      "template <typename... Args> void print(tuple<Args...> t);",
      "template <typename... T> void print(priority_queue<T...> pq);",
      "template <typename T> void print(stack<T> st);",
      "template <typename T> void print(queue<T> q);",
      "/* Template Datatypes Definitions */",
      "template <typename T> void print(T &&x) {",
      "  /*  This works for every container that supports range-based loop",
      "      i.e. vector, set, map, oset, omap, dequeue */",
      "  int f = 0;",
      "  cerr << '{';",
      "  for (auto &&i : x)",
      "    cerr << (f++ ? \",\" : \"\"), print(i);",
      "  cerr << \"}\";",
      "}",
      "template <typename T> void print(vector<vector<T>> mat) {",
      "  int f = 0;",
      "  cerr << \"\\n~~~~~\\n\";",
      "  for (auto &&i : mat) {",
      "    cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";",
      "  }",
      "  cerr << \"~~~~~\\n\";",
      "}",
      "template <typename T, size_t N, size_t M> void print(T (&mat)[N][M]) {",
      "  int f = 0;",
      "  cerr << \"\\n~~~~~\\n\";",
      "  for (auto &&i : mat) {",
      "    cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";",
      "  }",
      "  cerr << \"~~~~~\\n\";",
      "}",
      "template <typename F, typename S> void print(pair<F, S> x) {",
      "  cerr << '(';",
      "  print(x.first);",
      "  cerr << ',';",
      "  print(x.second);",
      "  cerr << ')';",
      "}",
      "template <typename T, size_t N> struct Tuple {",
      "  static void printTuple(T t) {",
      "    Tuple<T, N - 1>::printTuple(t);",
      "    cerr << \",\", print(get<N - 1>(t));",
      "  }",
      "};",
      "template <typename T> struct Tuple<T, 1> {",
      "  static void printTuple(T t) { print(get<0>(t)); }",
      "};",
      "template <typename... Args> void print(tuple<Args...> t) {",
      "  cerr << \"(\";",
      "  Tuple<decltype(t), sizeof...(Args)>::printTuple(t);",
      "  cerr << \")\";",
      "}",
      "template <typename... T> void print(priority_queue<T...> pq) {",
      "  int f = 0;",
      "  cerr << '{';",
      "  while (!pq.empty())",
      "    cerr << (f++ ? \",\" : \"\"), print(pq.top()), pq.pop();",
      "  cerr << \"}\";",
      "}",
      "template <typename T> void print(stack<T> st) {",
      "  int f = 0;",
      "  cerr << '{';",
      "  while (!st.empty())",
      "    cerr << (f++ ? \",\" : \"\"), print(st.top()), st.pop();",
      "  cerr << \"}\";",
      "}",
      "template <typename T> void print(queue<T> q) {",
      "  int f = 0;",
      "  cerr << '{';",
      "  while (!q.empty())",
      "    cerr << (f++ ? \",\" : \"\"), print(q.front()), q.pop();",
      "  cerr << \"}\";",
      "}",
      "/* Printer functions */",
      "void printer(const char *) {} /* Base Recursive */",
      "template <typename T, typename... V>",
      "void printer(const char *names, T &&head, V &&...tail) {",
      "  /* Using && to capture both lvalues and rvalues */",
      "  int i = 0;",
      "  for (size_t bracket = 0;",
      "       names[i] != '\\0' and (names[i] != ',' or bracket != 0); i++)",
      "    if (names[i] == '(' or names[i] == '<' or names[i] == '{')",
      "      bracket++;",
      "    else if (names[i] == ')' or names[i] == '>' or names[i] == '}')",
      "      bracket--;",
      "  cerr.write(names, i) << \" = \";",
      "  print(head);",
      "  if (sizeof...(tail))",
      "    cerr << \" ||\", printer(names + i + 1, tail...);",
      "  else",
      "    cerr << \"]\\n\";",
      "}",
      "/* PrinterArr */",
      "void printerArr(const char *) {} /* Base Recursive */",
      "template <typename T, typename... V>",
      "void printerArr(const char *names, T arr[], size_t N, V... tail) {",
      "  size_t ind = 0;",
      "  for (; names[ind] and names[ind] != ','; ind++)",
      "    cerr << names[ind];",
      "  for (ind++; names[ind] and names[ind] != ','; ind++)",
      "    ;",
      "  cerr << \" = {\";",
      "  for (size_t i = 0; i < N; i++)",
      "    cerr << (i ? \",\" : \"\"), print(arr[i]);",
      "  cerr << \"}\";",
      "  if (sizeof...(tail))",
      "    cerr << \" ||\", printerArr(names + ind + 1, tail...);",
      "  else",
      "    cerr << \"]\\n\";",
      "}",
      "} // namespace __DEBUG_UTIL__",
      "#ifndef ONLINE_JUDGE",
      "#define debug(...)                                                             \\",
      "  std::cerr << __LINE__ << \": [\",                                              \\",
      "      __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__)",
      "#define debugArr(...)                                                          \\",
      "  std::cerr << __LINE__ << \": [\",                                              \\",
      "      __DEBUG_UTIL__::printerArr(#__VA_ARGS__, __VA_ARGS__)",
      "#else",
      "#define debug(...)",
      "#define debugArr(...)",
      "#endif",
      "#"
    ],
    "description": "Debug Template"
  },
  "Random Number Generator": {
    "prefix": "RNG",
    "body": [
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());"
    ],
    "description": "Random Number Generator"
  },
  "Execution Time": {
    "prefix": "etime",
    "body": [
      "cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";"
    ],
    "description": "Execution Time"
  }
}
